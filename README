Grammar-Kit plugin

** THIS IS A WORK IN PROGRESS **

1.0
Adds to IntelliJ IDEA Platform support for our custom variant of BNF grammar files such as:
- Highlighting
- Completion
- Navigation
- Refactorings: inline rule, introduce rule
- Intentions: flip choice arguments

including:
- PsiBuilder-based PEG parser and PSI hierarchy generation


General usage instructions
1. Create grammar *.bnf file, see Grammar.bnf in the plugin code.
2. Generate parser/ElementTypes/PSI classes (Ctrl-Shift-G)
3. Add lexer, parser definition & plugin.xml
4. Mix-in resolve and other non-trivial functionality to PSI
5. Tune the grammar, regenerate code. Repeat if needed.
You've just build a custom language plugin (Approx. 1 day)


Quick grammar syntax overview:

See http://en.wikipedia.org/wiki/Parsing_expression_grammar for basic syntax.
Use ::= for ‚Üê symbol.
You can also use [ .. ] for optional sequences and { | | } for choices as these
variants are popular in real-world grammars.
Note that Grammar-Kit source code is the main example of Grammar-Kit application.

Basic syntax is extended with global and rule attributes (a name=value pairs enclosed in { } )
that control code generation. Rule attributes overrides global. Global attributes can specify
a rule name pattern to apply to: name("pattern_string")=value. This way you can keep grammar clean.
Rule modifiers:
1. private: PSI node will not be generated for this rule. Rules are public by default.
2. external: no code will be generated for this rule. Helps integrate generated and handwritten code.
3. left: support for left associativity, PSI node for this rule will enclose the one to the left.
4. inner: left injection, PSI node for this rule will be enclosed by the one to the left.
5. meta: marks this rule as meta rule. This type works in conjunction with external expressions.
You can combine the modifiers. Note that "private left" = "private left inner".

Meta rules & external expressions:
External expression << ... >> is simply an inlined external rule reference.
They can also be used to include meta rule with arguments. For example:
meta comma_separated_list ::= <<param>> ( ',' <<param>> ) *
option_list ::= <<comma_separated_list (OPTION1 | OPTION2 | OPTION3)>>
External rule consists of a body of external expression:
external manually_parsed_rule ::= methodName param1 param2 ...
Rules can be parameters as well in this case an instance of GeneratedParserUtilBase.Parser class is passed.

Tokens:
Tokens should appear in grammar file as is. All conflicts can be resolved by quotation.
If there is an attribute with the same value as single-quoted or double-quoted token then the corresponding
IElementType constant will be generated and matched against otherwise the token will be matched by text.
Text-matched tokens can span more than one real token returned by lexer.
External expressions and external rules interprets double- and single-quoted strings differently.
Generally anything that appears in external call is treated as parameter and is passed as is except
single-quoted strings. They are unquoted by parser generator.

Error recovery:
1. "pin" attribute (value: number or pattern) makes partially matched rule match if the specified prefix is matched.
This attribute tunes the parser to handle incomplete rules.
2. "recoverUntil" attribute (value: predicate rule) matches any number of tokens after the rule matching completes
with any result. This attribute helps parser recover when unmatched token sequence is encountered.

Generated parser structure:
For each rule and every its sub-expression in a grammar a static method is generated.
Sub-expression methods are named rule_name_K_L_.. where K, L, .. T are the ordinal position of this sub-expression
in the parent rule. Avoid naming your rules this way.
Generator can split parser code into several classes for better support of large grammars.
For simple cases parser will consists of several generated classes and GeneratedParserUtilBase class which is
generated (copied from Grammar-Kit actually) the first time generator is run. This class contains error recovery and
reporting code as well as completion functionality for parser-based completion provider. There is also code for basic
token matching.
Each external rule must be implemented the same way as generated i.e. by static method. Global "stubParser" attribute
should specify a GeneratedParserUtilBase subclass which contains all such implementations. They will be imported by
"import static .*" directive by all generated parsers.

Lexer:
Currently JFlex-based or any other lexer must be provided separately, you can use _BnfLexer.flex as a base.
IElementType constants generated by parser generator have to be recognized and returned by the lexer.
